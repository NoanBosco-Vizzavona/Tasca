# -*- coding: utf-8 -*-
"""Llama_Dataset_DZ.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TfoqlPi2xReRXQMojdQfC9oaSL-v8Ckh
"""

# âœ… TestDZLLaMa - Ã‰valuation complÃ¨te AVEC / SANS TashkÄ«l

!pip install -q transformers accelerate bitsandbytes peft scikit-learn

from transformers import AutoModelForCausalLM, AutoTokenizer
from sklearn.metrics import classification_report
import pandas as pd
import torch
from google.colab import files

# 1. Auth HF si nÃ©cessaire
from huggingface_hub import login
login()  # DÃ©commente si tu dois te reconnecter

import torch

torch.cuda.empty_cache()
torch.cuda.reset_max_memory_allocated()

# 2. Charger le modÃ¨le depuis Hugging Face
model_name = "Noanihio/llama-darja-token_10ep"
tokenizer = AutoTokenizer.from_pretrained(model_name)
model = AutoModelForCausalLM.from_pretrained(model_name, device_map="auto", load_in_8bit=True)

# 3. Upload du fichier test
uploaded = files.upload()
test_df = pd.read_csv("df_test_with_catt_DZ1.tsv", sep="\t")

test_df = pd.read_csv("df_test_with_catt_DZ1.tsv", sep="\t")

print(test_df.head())

label_map = {
    "0": "neutral",
    "1": "positive",
    "2": "negative",
    0: "neutral",
    1: "positive",
    2: "negative",
    "positive": "positive",
    "negative": "negative",
    "neutral": "neutral"
}
test_df["label"] = test_df["label"].astype(str).map(label_map).str.strip().str.lower()

# 5. Fonction de gÃ©nÃ©ration avec ou sans TashkÄ«l
def predict_sentiment(row, with_tashkeel=True):
    if with_tashkeel:
        prompt = f"<s>[Instruction]: Donne le sentiment de cette phrase.\n[Darja]: {row['tweet']}\n[TashkÄ«l]: {row['text_catt']}\n[Sentiment]:"
    else:
        prompt = f"<s>[Instruction]: Donne le sentiment de cette phrase.\n[Darja]: {row['tweet']}\n[Sentiment]:"

    inputs = tokenizer(prompt, return_tensors="pt").to("cuda")
    outputs = model.generate(**inputs, max_new_tokens=5)
    response = tokenizer.decode(outputs[0], skip_special_tokens=True)
    return response.split("[Sentiment]:")[-1].strip().lower()

print(test_df.head())

# 6. GÃ©nÃ©ration
print("\u23f3 GÃ©nÃ©ration AVEC TashkÄ«l...")
test_df["predicted_with"] = test_df.apply(lambda row: predict_sentiment(row, with_tashkeel=True), axis=1)

print("\u23f3 GÃ©nÃ©ration SANS TashkÄ«l...")
test_df["predicted_without"] = test_df.apply(lambda row: predict_sentiment(row, with_tashkeel=False), axis=1)

test_df.to_csv("test_predictions_darja_llama.csv", index=False, encoding="utf-8")

files.download("test_predictions_darja_llama.csv")

test_df = pd.read_csv("/content/test_predictions_darja_llama.csv")

print(test_df.head())
print(test_df.columns)

VALID_LABELS = ["neutral", "positive", "negative"]

def clean_label(label):
    label = str(label).lower().strip()
    for valid in VALID_LABELS:
        if valid in label:
            return valid
    return "unknown"

test_df["predicted_with"] = test_df["predicted_with"].apply(clean_label)
test_df["predicted_without"] = test_df["predicted_without"].apply(clean_label)

test_df["predicted_with"] = test_df["predicted_with"].astype(str).map(label_map).str.strip().str.lower()
test_df["predicted_without"] = test_df["predicted_without"].astype(str).map(label_map).str.strip().str.lower()



print(test_df.head())

print(test_df["predicted_with"].unique())
print(test_df["predicted_without"].unique())
print(test_df["label"].unique())

# 7. Evaluation des 2 versions
print("\nðŸ“Š RÃ©sultats AVEC TashkÄ«l")
print(classification_report(test_df["label"], test_df["predicted_with"], digits=3))

print("\nðŸ“Š RÃ©sultats SANS TashkÄ«l")
print(classification_report(test_df["label"], test_df["predicted_without"], digits=3))